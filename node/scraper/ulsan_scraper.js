#!/usr/bin/env node

/**
 * Node.js ê¸°ë°˜ ê³µê³  ìŠ¤í¬ë˜í•‘ ì‹œìŠ¤í…œ
 * 
 * ê¸°ëŠ¥:
 * 1. ë‚ ì§œ ê¸°ë°˜ í•„í„°ë§ìœ¼ë¡œ ì§€ì • ì—°ë„ê¹Œì§€ ìŠ¤í¬ë˜í•‘
 * 2. ë¦¬ìŠ¤íŠ¸ -> ìƒì„¸ í˜ì´ì§€ ì²˜ë¦¬
 * 3. ë‹¤ì–‘í•œ ë°©ì‹ì˜ ìƒì„¸ í˜ì´ì§€ ì ‘ê·¼ (URL, JavaScript)
 * 4. content.md íŒŒì¼ ìƒì„± (ë³¸ë¬¸ë§Œ ì¶”ì¶œ)
 * 5. ì²¨ë¶€íŒŒì¼ ë‹¤ìš´ë¡œë“œ (ë§í¬, POST, JavaScript ë°©ì‹)
 * 6. ì¤‘ë³µ ê²Œì‹œë¬¼ ìŠ¤í‚µ
 * 7. í´ë” êµ¬ì¡°: 001_ê²Œì‹œë¬¼ì´ë¦„/content.md, attachments/
 */

const { chromium } = require('playwright');
const cheerio = require('cheerio');
const axios = require('axios');
const https = require('https');
const fs = require('fs-extra');
const path = require('path');
const moment = require('moment');
const sanitize = require('sanitize-filename');
const yargs = require('yargs');
const config = require('./config');

class AnnouncementScraper {
    constructor(options = {}) {
        this.targetYear = options.targetYear || new Date().getFullYear();
        this.baseOutputDir = options.outputDir || 'scraped_data';
        this.siteCode = options.siteCode || 'default';
        this.outputDir = path.join(this.baseOutputDir, this.siteCode); // ì‚¬ì´íŠ¸ë³„ í´ë” ìƒì„±
        this.baseUrl = options.baseUrl;
        this.listSelector = options.listSelector;
        this.titleSelector = options.titleSelector || 'td:nth-child(2) a';
        this.dateSelector = options.dateSelector || 'td:last-child';
        this.browser = null;
        this.page = null;
        this.processedTitles = new Set();
        this.counter = 1;
        this.dateFormat = options.dateFormat || 'YYYY-MM-DD';
        this.options = options;
        this.goPage = options.goPage || null;
        this.targetDate = options.targetDate || null;
    }

    /**
     * ë¸Œë¼ìš°ì € ì´ˆê¸°í™”
     */
    async initBrowser() {
        console.log('ë¸Œë¼ìš°ì € ì´ˆê¸°í™” ì¤‘...');

        const maxRetries = 3;
        let retries = 0;

        while (retries < maxRetries) {
            try {
                // Playwrightë¡œ ë¸Œë¼ìš°ì € ì‹¤í–‰
                this.browser = await chromium.launch({
                    headless: config.browser.devMode ? false : true,  // PlaywrightëŠ” booleanë§Œ ì§€ì›
                    args: config.browser.launchOptions.args,
                    timeout: config.browser.launchOptions.timeout
                });

                // ìƒˆ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
                this.context = await this.browser.newContext({
                    userAgent: config.security.userAgent,
                    viewport: { width: 1280, height: 720 },
                    ignoreHTTPSErrors: config.browser.launchOptions.ignoreHTTPSErrors
                });

                this.page = await this.context.newPage();

                // íƒ€ì„ì•„ì›ƒ ì„¤ì •
                this.page.setDefaultTimeout(config.browser.timeouts.default);
                this.page.setDefaultNavigationTimeout(config.browser.timeouts.navigation);

                // ì—ëŸ¬ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
                this.browser.on('disconnected', () => {
                    console.warn('ë¸Œë¼ìš°ì € ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤.');
                });

                this.page.on('crash', () => {
                    console.warn('í˜ì´ì§€ í¬ë˜ì‹œ ë°œìƒ');
                });

                this.page.on('console', (msg) => {
                    // console.log, console.warn, console.error ë“± ëª¨ë“  ë¸Œë¼ìš°ì € ì½˜ì†” ë©”ì‹œì§€ë¥¼ ì²˜ë¦¬
                    console.log(`[ë¸Œë¼ìš°ì € ì½˜ì†”]: ${msg.text()}`);
                });

                this.page.on('pageerror', (error) => {
                    console.warn('í˜ì´ì§€ JavaScript ì˜¤ë¥˜:', error.message);
                });

                console.log('ë¸Œë¼ìš°ì € ì´ˆê¸°í™” ì™„ë£Œ');
                return;

            } catch (error) {
                retries++;
                console.error(`ë¸Œë¼ìš°ì € ì´ˆê¸°í™” ì‹¤íŒ¨ (ì‹œë„ ${retries}/${maxRetries}):`, error.message);

                if (this.browser) {
                    try {
                        await this.browser.close();
                    } catch (closeError) {
                        console.warn('ë¸Œë¼ìš°ì € ì¢…ë£Œ ì¤‘ ì˜¤ë¥˜:', closeError.message);
                    }
                }

                if (retries >= maxRetries) {
                    throw new Error(`ë¸Œë¼ìš°ì € ì´ˆê¸°í™” ${maxRetries}íšŒ ì‹¤íŒ¨: ${error.message}`);
                }

                // ì¬ì‹œë„ ì „ ëŒ€ê¸°
                await this.delay(2000 * retries);
            }
        }
    }

    /**
     * ê¸°ì¡´ ì œëª©ë“¤ ë¡œë“œ
     */
    async loadExistingTitles() {
        try {
            if (await fs.pathExists(this.outputDir)) {
                const existingFolders = await fs.readdir(this.outputDir);
                console.log(`ğŸ“ ê¸°ì¡´ í´ë” ${existingFolders.length}ê°œ ë°œê²¬`);

                existingFolders.forEach(folderName => {
                    const match = folderName.match(/^\d{3}_(.+)$/);
                    if (match) {
                        const existingTitle = match[1];
                        this.processedTitles.add(existingTitle);

                        // ì¹´ìš´í„° ì—…ë°ì´íŠ¸ (ê¸°ì¡´ í´ë” ì¤‘ ê°€ì¥ í° ë²ˆí˜¸ + 1)
                        const folderNumber = parseInt(folderName.substring(0, 3));
                        if (folderNumber >= this.counter) {
                            this.counter = folderNumber + 1;
                        }
                    }
                });

                console.log(`ğŸ“ ê¸°ì¡´ ì²˜ë¦¬ëœ ì œëª© ${this.processedTitles.size}ê°œ ë¡œë“œ ì™„ë£Œ`);
                console.log(`ğŸ”¢ ë‹¤ìŒ ì¹´ìš´í„°: ${this.counter}`);
            } else {
                console.log('ğŸ“‚ ì‹ ê·œ ì¶œë ¥ ë””ë ‰í† ë¦¬ ìƒì„±');
            }
        } catch (error) {
            console.log(`ğŸ“ ê¸°ì¡´ ì œëª© ë¡œë“œ ì‹¤íŒ¨ (ì •ìƒ - ì‹ ê·œ ì‹œì‘): ${error.message}`);
        }
    }

    /**
     * ë©”ì¸ ìŠ¤í¬ë˜í•‘ í”„ë¡œì„¸ìŠ¤
     */
    async scrape() {
        try {
            await this.initBrowser();
            await fs.ensureDir(this.outputDir);
            await this.loadExistingTitles();

            let currentPage = this.goPage || 1;
            let shouldContinue = true;
            let consecutiveErrors = 0;
            const maxConsecutiveErrors = 5;

            console.log(`\n=== ìŠ¤í¬ë˜í•‘ ì‹œì‘ ===`);
            if (this.targetDate) {
                const targetMoment = moment(this.targetDate, 'YYYYMMDD');
                console.log(`ëŒ€ìƒ ë‚ ì§œ: ${targetMoment.format('YYYY-MM-DD')} (${this.targetDate} ì´í›„ ê³µê³ ë§Œ ìˆ˜ì§‘)`);
            } else {
                console.log(`ëŒ€ìƒ ì—°ë„: ${this.targetYear}`);
            }
            if (this.goPage) {
                console.log(`ì‹œì‘ í˜ì´ì§€: ${this.goPage}`);
            }
            console.log(`ì‚¬ì´íŠ¸ ì½”ë“œ: ${this.siteCode}`);
            console.log(`ê¸°ë³¸ URL: ${this.baseUrl}`);
            console.log(`ì¶œë ¥ ë””ë ‰í† ë¦¬: ${this.outputDir}`);

            while (shouldContinue) {
                try {
                    console.log(`\n--- í˜ì´ì§€ ${currentPage} ì²˜ë¦¬ ì¤‘ ---`);

                    const announcements = await this.getAnnouncementList(currentPage);

                    if (!announcements || announcements.length === 0) {
                        console.log('ë” ì´ìƒ ê³µê³ ê°€ ì—†ìŠµë‹ˆë‹¤. ìŠ¤í¬ë˜í•‘ ì¢…ë£Œ.');
                        break;
                    }

                    // ì„±ê³µì ìœ¼ë¡œ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¨ ê²½ìš° ì—ëŸ¬ ì¹´ìš´íŠ¸ ë¦¬ì…‹
                    consecutiveErrors = 0;
                    for (const announcement of announcements) {
                        try {
                            const shouldStop = await this.processAnnouncement(announcement);
                            if (shouldStop) {
                                console.log(`\\n${this.targetYear}ë…„ ì´ì „ ê³µê³  ë°œê²¬. ìŠ¤í¬ë˜í•‘ ì¢…ë£Œ.`);
                                shouldContinue = false;
                                break;
                            }
                        } catch (announcementError) {
                            console.error(`ê³µê³  ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ (${announcement.title}):`, announcementError.message);
                            // ê°œë³„ ê³µê³  ì˜¤ë¥˜ëŠ” ì „ì²´ í”„ë¡œì„¸ìŠ¤ë¥¼ ì¤‘ë‹¨í•˜ì§€ ì•ŠìŒ
                            continue;
                        }
                    }

                    if (shouldContinue) {
                        currentPage++;
                        await this.delay(1000); // 1ì´ˆ ëŒ€ê¸°
                    }

                } catch (pageError) {
                    consecutiveErrors++;
                    console.error(`í˜ì´ì§€ ${currentPage} ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ (${consecutiveErrors}/${maxConsecutiveErrors}):`, pageError.message);

                    if (consecutiveErrors >= maxConsecutiveErrors) {
                        console.error('ì—°ì† ì˜¤ë¥˜ í•œë„ ì´ˆê³¼. ìŠ¤í¬ë˜í•‘ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.');
                        break;
                    }

                    // ì˜¤ë¥˜ ë°œìƒì‹œ ë” ê¸´ ëŒ€ê¸° ì‹œê°„
                    await this.delay(5000 * consecutiveErrors);
                    currentPage++;
                }
            }

        } catch (error) {
            console.error('ìŠ¤í¬ë˜í•‘ ì¤‘ ì¹˜ëª…ì  ì˜¤ë¥˜ ë°œìƒ:', error.message);
            console.error('ìŠ¤íƒ íŠ¸ë ˆì´ìŠ¤:', error.stack);
        } finally {
            await this.cleanup();
        }
    }

    /**
     * ê³µê³  ë¦¬ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
     */
    async getAnnouncementList(pageNum) {
        const maxRetries = 3;
        let retries = 0;

        while (retries < maxRetries) {
            try {
                const listUrl = this.buildListUrl(pageNum);
                console.log(`ë¦¬ìŠ¤íŠ¸ URL: ${listUrl}`);

                // ë¸Œë¼ìš°ì €ë‚˜ í˜ì´ì§€ê°€ ì¢…ë£Œëœ ê²½ìš° ì¬ì´ˆê¸°í™”
                if (!this.browser || !this.page || this.page.isClosed()) {
                    console.log('ë¸Œë¼ìš°ì € ì—°ê²°ì´ ëŠì–´ì ¸ ì¬ì´ˆê¸°í™”í•©ë‹ˆë‹¤...');
                    await this.initBrowser();
                }

                await this.page.goto(listUrl, {
                    waitUntil: 'networkidle',
                    timeout: 30000
                });


                // ë™ì  ì»¨í…ì¸  ë¡œë”© ëŒ€ê¸°
                await this.page.waitForTimeout(4000);

                // ë¦¬ìŠ¤íŠ¸ ìš”ì†Œë“¤ ì¶”ì¶œ
                const announcements = await this.page.evaluate((selectors) => {

                    const rows = document.querySelectorAll(selectors.listSelector);

                    const results = [];

                    rows.forEach((row, index) => {
                        // í—¤ë” í–‰ ìŠ¤í‚µ
                        if (index === 0 && row.querySelector('th')) return;

                        const titleElement = row.querySelector(selectors.titleSelector);
                        const dateElement = row.querySelector(selectors.dateSelector);
                        const linkElement = row.querySelector(".a1");

                        if (titleElement && dateElement) {
                            const title = titleElement.textContent.trim();
                            const dateText = dateElement.textContent.replace("ë“±ë¡ì¼:", '').trim();
                            // ë‹¤ì–‘í•œ ë°©ì‹ìœ¼ë¡œ ë§í¬ ì •ë³´ ì¶”ì¶œ
                            let href = titleElement.href;
                            if (linkElement) {
                                href = linkElement.href
                            }

                            const onclick = titleElement.getAttribute('onclick');
                            const dataAction = titleElement.getAttribute('data-action');

                            results.push({
                                title,
                                dateText,
                                link: href,
                                onclick: onclick,
                                dataAction: dataAction,
                                listDate: dateText
                            });
                        }
                    });

                    return results;
                }, {
                    listSelector: this.listSelector,
                    titleSelector: this.titleSelector,
                    dateSelector: this.dateSelector
                });


                console.log(`ë¦¬ìŠ¤íŠ¸ì—ì„œ ${announcements.length}ê°œ ê³µê³  ë°œê²¬`);
                return announcements;

            } catch (error) {
                retries++;
                console.error(`ë¦¬ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨ (ì‹œë„ ${retries}/${maxRetries}):`, error.message);

                if (retries >= maxRetries) {
                    console.error('ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼. ë¹ˆ ë°°ì—´ ë°˜í™˜.');
                    return [];
                }

                // ì¬ì‹œë„ ì „ ëŒ€ê¸°
                await this.delay(2000 * retries);
            }
        }
    }

    /**
     * ê°œë³„ ê³µê³  ì²˜ë¦¬
     */
    async processAnnouncement(announcement) {
        try {
            console.log(`\nì²˜ë¦¬ ì¤‘: ${announcement.title}`);

            // 1. ë¦¬ìŠ¤íŠ¸ì—ì„œ ë‚ ì§œ í™•ì¸
            const listDate = this.extractDate(announcement.dateText);

            // targetDateê°€ ì„¤ì •ëœ ê²½ìš° í•´ë‹¹ ë‚ ì§œ ì´ì „ ì²´í¬
            if (this.targetDate) {
                const targetMoment = moment(this.targetDate, 'YYYYMMDD');
                if (listDate && listDate.isBefore(targetMoment)) {
                    console.log(`ë¦¬ìŠ¤íŠ¸ ë‚ ì§œ ${listDate.format('YYYY-MM-DD')}ê°€ ëŒ€ìƒ ë‚ ì§œ(${targetMoment.format('YYYY-MM-DD')}) ì´ì „ì…ë‹ˆë‹¤.`);
                    return true; // ìŠ¤í¬ë˜í•‘ ì¤‘ë‹¨
                }
            }
            // targetYear ì²´í¬ (ê¸°ì¡´ í˜¸í™˜ì„± ìœ ì§€)
            else if (listDate && listDate.year() < this.targetYear) {
                console.log(`ë¦¬ìŠ¤íŠ¸ ë‚ ì§œ ${listDate.format('YYYY-MM-DD')}ê°€ ëŒ€ìƒ ì—°ë„(${this.targetYear}) ì´ì „ì…ë‹ˆë‹¤.`);
                return true; // ìŠ¤í¬ë˜í•‘ ì¤‘ë‹¨
            }

            // 2. ì¤‘ë³µ ê²Œì‹œë¬¼ ì²´í¬ (ì œëª©ë§Œìœ¼ë¡œ ë¹„êµ)
            const sanitizedTitle = sanitize(announcement.title).substring(0, 100);

            // ë©”ëª¨ë¦¬ ê¸°ë°˜ ì²´í¬
            if (this.processedTitles.has(announcement.title) || this.processedTitles.has(sanitizedTitle)) {
                console.log(`âŒ ì¤‘ë³µ ê²Œì‹œë¬¼ ìŠ¤í‚µ (ë©”ëª¨ë¦¬): ${announcement.title}`);
                return false;
            }

            // íŒŒì¼ì‹œìŠ¤í…œ ê¸°ë°˜ ì²´í¬
            try {
                if (await fs.pathExists(this.outputDir)) {
                    const existingFolders = await fs.readdir(this.outputDir);
                    for (const folderName of existingFolders) {
                        const match = folderName.match(/^\d{3}_(.+)$/);
                        if (match) {
                            const existingTitle = match[1];
                            if (existingTitle === sanitizedTitle || existingTitle === announcement.title) {
                                console.log(`âŒ ì¤‘ë³µ ê²Œì‹œë¬¼ ìŠ¤í‚µ (íŒŒì¼ì‹œìŠ¤í…œ): ${announcement.title}`);
                                this.processedTitles.add(announcement.title);
                                this.processedTitles.add(sanitizedTitle);
                                return false;
                            }
                        }
                    }
                }
            } catch (fsError) {
                console.log(`íŒŒì¼ì‹œìŠ¤í…œ ì¤‘ë³µ ì²´í¬ ì‹¤íŒ¨: ${fsError.message}`);
            }

            // 3. ìƒì„¸ í˜ì´ì§€ë¡œ ì´ë™
            const detailContent = await this.getDetailContent(announcement);
            if (!detailContent) {
                console.log('ìƒì„¸ í˜ì´ì§€ ì ‘ê·¼ ì‹¤íŒ¨');
                return false;
            }

            // 4. ìƒì„¸ í˜ì´ì§€ì—ì„œ ë‚ ì§œ ì¬í™•ì¸
            if (this.targetDate) {
                const targetMoment = moment(this.targetDate, 'YYYYMMDD');
                if (detailContent.date && detailContent.date.isBefore(targetMoment)) {
                    console.log(`ìƒì„¸ í˜ì´ì§€ ë‚ ì§œ ${detailContent.date.format('YYYY-MM-DD')}ê°€ ëŒ€ìƒ ë‚ ì§œ(${targetMoment.format('YYYY-MM-DD')}) ì´ì „ì…ë‹ˆë‹¤.`);
                    return true; // ìŠ¤í¬ë˜í•‘ ì¤‘ë‹¨
                }
            }
            // targetYear ì²´í¬ (ê¸°ì¡´ í˜¸í™˜ì„± ìœ ì§€)
            else if (detailContent.date && detailContent.date.year() < this.targetYear) {
                console.log(`ìƒì„¸ í˜ì´ì§€ ë‚ ì§œ ${detailContent.date.format('YYYY-MM-DD')}ê°€ ëŒ€ìƒ ì—°ë„(${this.targetYear}) ì´ì „ì…ë‹ˆë‹¤.`);
                return true; // ìŠ¤í¬ë˜í•‘ ì¤‘ë‹¨
            }

            // 5. í´ë” ìƒì„± ë° íŒŒì¼ ì €ì¥
            await this.saveAnnouncement(announcement, detailContent);

            this.processedTitles.add(announcement.title);
            console.log(`ì²˜ë¦¬ ì™„ë£Œ: ${announcement.title}`);

            return false; // ê³„ì† ì§„í–‰

        } catch (error) {
            console.error(`ê³µê³  ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ (${announcement.title}):`, error);
            return false;
        }
    }

    /**
     * ìƒì„¸ í˜ì´ì§€ ë‚´ìš© ê°€ì ¸ì˜¤ê¸°
     */
    async getDetailContent(announcement) {
        const maxRetries = 3;
        let retries = 0;

        while (retries < maxRetries) {
            try {
                const detailUrl = await this.buildDetailUrl(announcement);

                if (!detailUrl) {
                    console.log('ìƒì„¸ í˜ì´ì§€ URL êµ¬ì„± ì‹¤íŒ¨');
                    return null;
                }


                // ë¸Œë¼ìš°ì €ë‚˜ í˜ì´ì§€ê°€ ì¢…ë£Œëœ ê²½ìš° ì¬ì´ˆê¸°í™”
                if (!this.browser || !this.page || this.page.isClosed()) {
                    console.log('ë¸Œë¼ìš°ì € ì—°ê²°ì´ ëŠì–´ì ¸ ì¬ì´ˆê¸°í™”í•©ë‹ˆë‹¤...');
                    await this.initBrowser();
                }

                // ìƒì„¸ í˜ì´ì§€ë¡œ ì´ë™
                await this.page.goto(detailUrl, {
                    waitUntil: 'networkidle',
                    timeout: 30000
                });
                await this.page.waitForTimeout(2000);

                const evalOptions = { ...this.options, announcement }

                // í˜ì´ì§€ ë‚´ìš© ì¶”ì¶œ
                const content = await this.page.evaluate((options) => {
                    // í—¤ë”, ì‚¬ì´ë“œë°”, í‘¸í„° ë“± ì œê±°
                    const excludeSelectors = [
                        'header', 'nav', 'aside', 'footer',
                        '.header', '.nav', '.sidebar', '.footer',
                        '.menu', '.navigation', '.breadcrumb'
                    ];
                    const {
                        announcement
                    } = options;

                    excludeSelectors.forEach(selector => {
                        const elements = document.querySelectorAll(selector);
                        elements.forEach(el => el.remove());
                    });

                    // ë³¸ë¬¸ ì¶”ì¶œ ì‹œë„
                    let mainContent = null;
                    const contentSelectors = [
                        '.s-v-board-default', '.content_box', '.program--contents',
                        '.bbs_skin', '.view_box', '#content',
                        '.board-content', '.view-content',
                        'div.table-responsive'
                    ];

                    for (const selector of contentSelectors) {
                        const element = document.querySelector(selector);
                        if (element) {
                            mainContent = element;
                            break;
                        }
                    }

                    if (!mainContent) {
                        mainContent = document.body;
                    }


                    // ë‚ ì§œ ì¶”ì¶œ
                    let dateText = '';
                    // const dateSelectors = [
                    //     '.date', '.reg-date', '.write-date', '.post-date',
                    //     '[class*="date"]', '[id*="date"]'
                    // ];

                    // for (const selector of dateSelectors) {
                    //     const dateElement = document.querySelector(selector);
                    //     if (dateElement) {
                    //         dateText = dateElement.textContent.trim();
                    //         break;
                    //     }
                    // }

                    //í˜„ì¬ ë“±ë¡ì¼ì˜ ê²½ìš°ëŠ” ì•„ì˜ˆ í´ë˜ìŠ¤ ë“±ì´ ì§€ì •ë˜ì–´ ìˆì§€ ì•Šë‹¤.
                    if (!dateText) {
                        //ì´ ë¶€ë¶„ì„ ì²˜ë¦¬í•˜ì
                        console.log("!!!!dateText ì¬ì²˜ë¦¬")

                        //ì´ ë¶€ë¶„ì„ ì²˜ë¦¬í•˜ì
                        if (announcement && announcement.listDate) {
                            dateText = announcement.listDate
                        } else {
                            const dateElement = document.querySelector('.p-author__info .p-split');

                            if (dateElement) {
                                // Get the text content, remove the "ì‘ì„±ì¼ :" part, and trim whitespace
                                dateText = dateElement.textContent.replace('ì‘ì„±ì¼ :', '').trim();
                            }
                        }
                    }

                    // ì²¨ë¶€íŒŒì¼ ë§í¬ ì¶”ì¶œ
                    const attachments = [];


                    const downloadLinks = document.querySelectorAll('a[href*="download.jsp"]');

                    console.log("downloadLinks", downloadLinks)
                    downloadLinks.forEach(link => {
                        const fileName = link.textContent.trim();
                        const fileURL = link.href;

                        attachments.push({
                            name: fileName,
                            url: fileURL
                        });
                    });


                    console.log("attachments", attachments)


                    // í…ìŠ¤íŠ¸ë§Œ ì¶”ì¶œ (ë§ˆí¬ë‹¤ìš´ í˜•ì‹)
                    const textContent = mainContent.innerText || mainContent.textContent || '';

                    return {
                        content: textContent.trim(),
                        dateText: dateText,
                        attachments: attachments
                    };

                }, evalOptions);

                // ë‚ ì§œ íŒŒì‹±
                const detailDate = this.extractDate(content.dateText);

                return {
                    url: detailUrl,
                    content: content.content,
                    date: detailDate,
                    attachments: content.attachments
                };

            } catch (error) {
                retries++;
                console.error(`ìƒì„¸ í˜ì´ì§€ ì²˜ë¦¬ ì‹¤íŒ¨ (ì‹œë„ ${retries}/${maxRetries}):`, error.message);

                if (retries >= maxRetries) {
                    console.error('ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼. null ë°˜í™˜.');
                    return null;
                }

                // ì¬ì‹œë„ ì „ ëŒ€ê¸°
                await this.delay(2000 * retries);
            }
        }
    }

    /**
     * ê³µê³  ì €ì¥
     */
    async saveAnnouncement(announcement, detailContent) {
        try {
            // í´ë”ëª… ìƒì„±
            const sanitizedTitle = sanitize(announcement.title).substring(0, 100);
            const folderName = `${String(this.counter).padStart(3, '0')}_${sanitizedTitle}`;
            const folderPath = path.join(this.outputDir, folderName);

            await fs.ensureDir(folderPath);

            // ì²¨ë¶€íŒŒì¼ ë‹¤ìš´ë¡œë“œ ë° URL ì •ë³´ ìˆ˜ì§‘
            let downloadUrlInfo = {};
            if (detailContent.attachments && detailContent.attachments.length > 0) {
                downloadUrlInfo = await this.downloadAttachments(detailContent.attachments, folderPath);

                // ì²¨ë¶€íŒŒì¼ì— ë‹¤ìš´ë¡œë“œ ì •ë³´ ì¶”ê°€
                detailContent.attachments.forEach(attachment => {
                    const fileName = attachment.name;
                    if (downloadUrlInfo[fileName]) {
                        attachment.downloadInfo = downloadUrlInfo[fileName];
                    }
                });
            }

            // content.md ìƒì„± (ë‹¤ìš´ë¡œë“œ URL ì •ë³´ í¬í•¨)
            const contentMd = this.generateMarkdownContent(announcement, detailContent);
            await fs.writeFile(path.join(folderPath, 'content.md'), contentMd, 'utf8');

            this.counter++;

        } catch (error) {
            console.error('ê³µê³  ì €ì¥ ì‹¤íŒ¨:', error);
        }
    }

    /**
     * ì²¨ë¶€íŒŒì¼ ë‹¤ìš´ë¡œë“œ
     */
    async downloadAttachments(attachments, folderPath) {
        const downloadUrlInfo = {};
        try {
            const attachDir = path.join(folderPath, 'attachments');
            await fs.ensureDir(attachDir);

            console.log(`${attachments.length}ê°œ ì²¨ë¶€íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì¤‘...`);

            for (let i = 0; i < attachments.length; i++) {
                const attachment = attachments[i];
                const result = await this.downloadSingleAttachment(attachment, attachDir, i + 1);
                if (result) {
                    Object.assign(downloadUrlInfo, result);
                }
                await this.delay(500); // 0.5ì´ˆ ëŒ€ê¸°
            }

        } catch (error) {
            console.error('ì²¨ë¶€íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:', error);
        }
        return downloadUrlInfo;
    }


    /**
     * ë‹¨ì¼ ì²¨ë¶€íŒŒì¼ ë‹¤ìš´ë¡œë“œ
     */
    async downloadSingleAttachment(attachment, attachDir, index) {
        try {
            let downloadUrl = attachment.url;
            let fileName = attachment.name || `attachment_${index}`;
            let actualDownloadUrl = null;
            let downloadType = 'direct';

            console.log("attachment", attachment)

            console.log("downloadUrl", downloadUrl)
            // JavaScript ë°©ì‹ ì²˜ë¦¬
            if (attachment.onclick) {
                downloadType = 'onclick';
                // goDownload íŒ¨í„´ ì²˜ë¦¬
                const goDownloadMatch = attachment.onclick.match(/goDownload\(\s*['"]([^'"]*)['"]\s*,\s*['"]([^'"]*)['"]\s*,\s*['"]([^'"]*)['"]\s*\)/);

                if (goDownloadMatch) {
                    const [, originalName, serverName, serverPath] = goDownloadMatch;
                    // ì‹¤ì œ goDownload í•¨ìˆ˜ì™€ ë™ì¼í•œ URL íŒ¨í„´ ì‚¬ìš©
                    const enc_user_file_nm = encodeURIComponent(originalName);
                    const enc_sys_file_nm = encodeURIComponent(serverName);
                    const enc_file_path = encodeURIComponent(serverPath);
                    downloadUrl = `https://eminwon.osan.go.kr/emwp/jsp/ofr/FileDown.jsp?user_file_nm=${enc_user_file_nm}&sys_file_nm=${enc_sys_file_nm}&file_path=${enc_file_path}`;
                    // fileName = originalName; // ì›ë³¸ íŒŒì¼ëª… ì‚¬ìš©
                    downloadType = 'goDownload';
                } else {
                    // ê¸°ì¡´ onclick ì´ë²¤íŠ¸ì—ì„œ URL ì¶”ì¶œ ì‹œë„
                    const match = attachment.onclick.match(/(?:window\.open|location\.href|download)\(['"]([^'"]*)['"]\)/);
                    if (match) {
                        downloadUrl = match[1];
                    }
                }

            }

            // ìƒëŒ€ URLì„ ì ˆëŒ€ URLë¡œ ë³€í™˜
            if (downloadUrl && !downloadUrl.startsWith('http')) {
                console.log('ìƒëŒ€ URLì„ ì ˆëŒ€ URLë¡œ ë³€í™˜')
                downloadUrl = new URL(downloadUrl, this.baseUrl).toString();
            }

            console.log("downloadUrl", downloadUrl)


            if (!downloadUrl || !downloadUrl.startsWith('http')) {
                console.log(`ìœ íš¨í•˜ì§€ ì•Šì€ ë‹¤ìš´ë¡œë“œ URL: ${downloadUrl}`);
                return {
                    [fileName]: {
                        originalUrl: attachment.url,
                        originalOnclick: attachment.onclick,
                        actualDownloadUrl: null,
                        downloadType: downloadType,
                        error: 'Invalid URL'
                    }
                };
            }

            actualDownloadUrl = downloadUrl;

            // POST ë°©ì‹ ë˜ëŠ” íŠ¹ë³„í•œ ì²˜ë¦¬ê°€ í•„ìš”í•œ ê²½ìš°
            if (attachment.onclick && attachment.onclick.includes('submit')) {
                await this.downloadViaForm(attachment, attachDir, fileName);
            } else {
                // ì¼ë°˜ ë§í¬ ë°©ì‹
                await this.downloadViaLink(downloadUrl, attachDir, fileName);
            }


            return {
                [fileName]: {
                    originalUrl: attachment.url,
                    originalOnclick: attachment.onclick,
                    actualDownloadUrl: actualDownloadUrl,
                    downloadType: downloadType,
                    fileName: fileName
                }
            };
        } catch (error) {
            console.error(`ì²¨ë¶€íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨ (${attachment.name}):`, error);
            return {
                [attachment.name || `attachment_${index}`]: {
                    originalUrl: attachment.url,
                    originalOnclick: attachment.onclick,
                    actualDownloadUrl: null,
                    downloadType: 'error',
                    error: error.message
                }
            };
        }
    }

    /**
     * ë¸Œë¼ìš°ì € í´ë¦­ì„ í†µí•œ ë‹¤ìš´ë¡œë“œ (ì‹¤ì œ ë§í¬ í´ë¦­)
     */
    async downloadViaBrowserClick(url, userFileNm, sysFileNm, filePath, originalFileName, attachDir, displayFileName) {
        try {
            console.log('ğŸ–±ï¸ ë¸Œë¼ìš°ì €ì—ì„œ ì‹¤ì œ ë§í¬ í´ë¦­ ë°©ì‹ ë‹¤ìš´ë¡œë“œ ì‹œì‘...');

            // íŒŒì¼ëª… ì •ë¦¬
            const cleanFileName = sanitize(displayFileName, { replacement: '_' });
            const expectedFilePath = path.join(attachDir, cleanFileName);

            console.log(`ë‹¤ìš´ë¡œë“œí•  íŒŒì¼: ${cleanFileName}`);
            console.log(`ì €ì¥ ê²½ë¡œ: ${expectedFilePath}`);

            // ë””ë ‰í† ë¦¬ê°€ ì—†ìœ¼ë©´ ë¨¼ì € ìƒì„±
            await fs.ensureDir(attachDir);

            // CDP ì„¸ì…˜ ì„¤ì •
            const client = await this.page.context().newCDPSession(this.page);

            // ë‹¤ìš´ë¡œë“œ ë™ì‘ ì„¤ì •
            await client.send('Page.setDownloadBehavior', {
                behavior: 'allow',
                downloadPath: attachDir
            });

            // ë‹¤ìš´ë¡œë“œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
            const downloadPromise = new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('ë‹¤ìš´ë¡œë“œ íƒ€ì„ì•„ì›ƒ (10ì´ˆ)'));
                }, 10000);

                const downloadHandler = async (download) => {
                    try {
                        clearTimeout(timeout);

                        // ë‹¤ìš´ë¡œë“œê°€ ì œì•ˆí•œ íŒŒì¼ëª…ìœ¼ë¡œ ì €ì¥ (ì„œë²„ê°€ ì œê³µí•œ ì´ë¦„)
                        const suggestedFilename = download.suggestedFilename();
                        const tempPath = path.join(attachDir, suggestedFilename);
                        console.log(`ì„œë²„ ì œì•ˆ íŒŒì¼ëª…: ${suggestedFilename}`);

                        await download.saveAs(tempPath);

                        // íŒŒì¼ í¬ê¸° í™•ì¸
                        const stats = await fs.stat(tempPath);
                        console.log(`ë‹¤ìš´ë¡œë“œ ì™„ë£Œ: ${tempPath} (${stats.size} bytes)`);

                        // 134B ì—ëŸ¬ íŒŒì¼ ì²´í¬
                        if (stats.size < 200) {
                            try {
                                const content = await fs.readFile(tempPath, 'utf8');
                                if (content.includes('ì˜ëª»ëœ ê²½ë¡œ')) {
                                    // ì—ëŸ¬ íŒŒì¼ ì‚­ì œ
                                    await fs.unlink(tempPath);
                                    throw new Error('ì—ëŸ¬ í˜ì´ì§€ ë‹¤ìš´ë¡œë“œë¨ (134B)');
                                }
                            } catch (readError) {
                                // ë°”ì´ë„ˆë¦¬ íŒŒì¼ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì½ê¸° ì˜¤ë¥˜ëŠ” ë¬´ì‹œ
                            }
                        }

                        // ì •ìƒ íŒŒì¼ì¸ ê²½ìš° ì›í•˜ëŠ” ì´ë¦„ìœ¼ë¡œ ë³€ê²½
                        const finalPath = path.join(attachDir, cleanFileName);
                        if (tempPath !== finalPath) {
                            // ì´ë¯¸ ì¡´ì¬í•˜ëŠ” íŒŒì¼ì´ ìˆìœ¼ë©´ ì‚­ì œ
                            if (await fs.pathExists(finalPath)) {
                                await fs.unlink(finalPath);
                            }
                            await fs.move(tempPath, finalPath, { overwrite: true });
                            console.log(`íŒŒì¼ëª… ë³€ê²½: ${suggestedFilename} â†’ ${cleanFileName}`);
                        }
                        console.log(`âœ… íŒŒì¼ ì €ì¥ ì™„ë£Œ: ${finalPath} (${stats.size} bytes)`);

                        resolve({ success: true, savedPath: finalPath, fileSize: stats.size });
                    } catch (error) {
                        clearTimeout(timeout);
                        reject(error);
                    }
                };

                this.page.once('download', downloadHandler);
            });

            // í˜„ì¬ í˜ì´ì§€ì—ì„œ í•´ë‹¹ íŒŒì¼ëª…ì˜ ë§í¬ë¥¼ ì°¾ì•„ì„œ í´ë¦­
            console.log('í˜ì´ì§€ì—ì„œ ì²¨ë¶€íŒŒì¼ ë§í¬ ì°¾ê¸°...');

            const clicked = await this.page.evaluate((targetFileName) => {
                // ëª¨ë“  ì²¨ë¶€íŒŒì¼ ë§í¬ ì°¾ê¸°
                const links = document.querySelectorAll('a[href*="gourl"]');

                for (const link of links) {
                    // ë§í¬ í…ìŠ¤íŠ¸ë‚˜ titleì´ ëŒ€ìƒ íŒŒì¼ëª…ê³¼ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
                    if (link.textContent.includes(targetFileName.substring(0, 20)) ||
                        (link.title && link.title.includes(targetFileName.substring(0, 20)))) {
                        console.log('ì°¾ì€ ë§í¬:', link.href);
                        link.click();
                        return true;
                    }
                }

                // ëª» ì°¾ì•˜ìœ¼ë©´ ëª¨ë“  fnFileDown ë§í¬ ì¤‘ ì²«ë²ˆì§¸ í´ë¦­
                if (links.length > 0) {
                    console.log('ì²«ë²ˆì§¸ fnFileDown ë§í¬ í´ë¦­:', links[0].href);
                    links[0].click();
                    return true;
                }

                return false;
            }, displayFileName);

            if (!clicked) {
                throw new Error('í˜ì´ì§€ì—ì„œ ë‹¤ìš´ë¡œë“œ ë§í¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ');
            }

            // ë‹¤ìš´ë¡œë“œ ì™„ë£Œ ëŒ€ê¸°
            console.log('ë‹¤ìš´ë¡œë“œ ëŒ€ê¸° ì¤‘...');
            const result = await downloadPromise;

            // ê²°ê³¼ ê²€ì¦
            if (result.fileSize < 200) {
                throw new Error(`íŒŒì¼ì´ ë„ˆë¬´ ì‘ìŒ (${result.fileSize} bytes) - ì—ëŸ¬ í˜ì´ì§€ì¼ ê°€ëŠ¥ì„±`);
            }

            return result;

        } catch (error) {
            console.error('ë¸Œë¼ìš°ì € ì‹¤ì œ í´ë¦­ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:', error.message);

            // íƒ€ì„ì•„ì›ƒì´ë‚˜ ë‹¤ìš´ë¡œë“œ ì´ë²¤íŠ¸ê°€ ë°œìƒí•˜ì§€ ì•Šì€ ê²½ìš°
            // ì§ì ‘ HTTP ìš”ì²­ ë°©ì‹ìœ¼ë¡œ ì‹œë„
            console.log('í´ë°±: ì§ì ‘ HTTP ìš”ì²­ ë°©ì‹ ì‹œë„...');

            // Refererì™€ Cookieë¥¼ í˜„ì¬ í˜ì´ì§€ì—ì„œ ê°€ì ¸ì˜¤ê¸°
            const cookies = await this.page.context().cookies();
            const cookieString = cookies.map(c => `${c.name}=${c.value}`).join('; ');
            const currentUrl = this.page.url();

            return await this.downloadViaAxiosWithSession(url, userFileNm, sysFileNm, filePath, attachDir, displayFileName, cookieString, currentUrl);
        }
    }

    /**
     * Axiosë¥¼ ì‚¬ìš©í•œ ì„¸ì…˜ ê¸°ë°˜ ë‹¤ìš´ë¡œë“œ
     */
    async downloadViaAxiosWithSession(url, userFileNm, sysFileNm, filePath, attachDir, displayFileName, cookieString, referer) {
        try {
            console.log('Axios ì„¸ì…˜ ê¸°ë°˜ ë‹¤ìš´ë¡œë“œ ì‹œì‘...');

            const downloadUrl = url || 'https://eminwon.hanma.go.kr/emwp/jsp/ofr/FileDownNew.jsp';
            const postData = `user_file_nm=${userFileNm}&sys_file_nm=${sysFileNm}&file_path=${filePath}`;

            console.log(`Cookie: ${cookieString ? 'Present' : 'None'}`);
            console.log(`Referer: ${referer}`);

            const response = await axios({
                method: 'POST',
                url: downloadUrl,
                data: postData,
                responseType: 'stream',
                timeout: 30000,
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                    'Accept': '*/*',
                    'Accept-Encoding': 'gzip, deflate, br',
                    'Accept-Language': 'ko-KR,ko;q=0.9,en;q=0.8',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                    'Referer': referer,
                    'Cookie': cookieString
                }
            });

            const safeFileName = displayFileName.replace(/[\/\\:*?"<>|]/g, '_');
            const savePath = path.join(attachDir, safeFileName);
            const writer = fs.createWriteStream(savePath);

            response.data.pipe(writer);

            return new Promise((resolve, reject) => {
                writer.on('finish', async () => {
                    // íŒŒì¼ í¬ê¸° í™•ì¸
                    const stats = await fs.stat(savePath);
                    if (stats.size < 200) {
                        const content = await fs.readFile(savePath, 'utf8');
                        if (content.includes('ì˜ëª»ëœ ê²½ë¡œ')) {
                            await fs.unlink(savePath);
                            reject(new Error('ì—ëŸ¬ í˜ì´ì§€ ë‹¤ìš´ë¡œë“œë¨'));
                            return;
                        }
                    }
                    console.log(`âœ… íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì„±ê³µ: ${savePath} (${stats.size} bytes)`);
                    resolve({ success: true, savedPath: savePath, fileName: displayFileName, fileSize: stats.size });
                });
                writer.on('error', reject);
            });

        } catch (error) {
            console.error('Axios ì„¸ì…˜ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨:', error.message);
            throw error;
        }
    }

    /**
     * ë§í¬ ë°©ì‹ ë‹¤ìš´ë¡œë“œ
     */
    async downloadViaLink(url, attachDir, fileName) {
        try {

            const response = await axios({
                method: 'GET',
                url: url,
                responseType: 'stream',
                timeout: 30000,
                headers: {
                    'Accept': '*/*',
                    'Accept-Encoding': 'gzip, deflate, br',
                    'Accept-Language': 'ko-KR,ko;q=0.9,en;q=0.8',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                },
                httpsAgent: new https.Agent({
                    rejectUnauthorized: false // SSL ì¸ì¦ì„œ ê²€ì¦ ë¹„í™œì„±í™”
                })
            });

            // íŒŒì¼ëª… ê²°ì • (í•œê¸€ëª… ì§€ì›)
            const contentDisposition = response.headers['content-disposition'];

            // goDownloadì—ì„œ ì˜¨ ì›ë³¸ íŒŒì¼ëª…ì´ ìˆëŠ” ê²½ìš° ìš°ì„  ì‚¬ìš© (í•œê¸€ ë³´ì¡´)
            const isFromGoDownload = fileName && !fileName.startsWith('attachment_');

            if (!isFromGoDownload && contentDisposition) {
                // goDownloadê°€ ì•„ë‹Œ ê²½ìš°ì—ë§Œ Content-Dispositionì—ì„œ íŒŒì¼ëª… ì¶”ì¶œ
                let extractedFileName = null;

                // 1ìˆœìœ„: UTF-8 ì¸ì½”ë”©ëœ íŒŒì¼ëª… ì²˜ë¦¬ (filename*=UTF-8''encoded-name)
                const utf8Match = contentDisposition.match(/filename\*=UTF-8''([^;]+)/i);
                if (utf8Match) {
                    try {
                        extractedFileName = decodeURIComponent(utf8Match[1]);
                        console.log('UTF-8 íŒŒì¼ëª… ì¶”ì¶œ:', extractedFileName);
                    } catch (e) {
                        console.log('UTF-8 íŒŒì¼ëª… ë””ì½”ë”© ì‹¤íŒ¨:', e.message);
                    }
                }

                // 2ìˆœìœ„: ì¼ë°˜ filename ì²˜ë¦¬
                if (!extractedFileName) {
                    const match = contentDisposition.match(/filename[^;=\n]*=((['"]).*?\2|[^;\n]*)/);
                    if (match) {
                        extractedFileName = match[1].replace(/['"]/g, '').trim();

                        // URL ì¸ì½”ë”©ëœ ê²½ìš° ë””ì½”ë”© ì‹œë„
                        if (extractedFileName.includes('%')) {
                            try {
                                const decoded = decodeURIComponent(extractedFileName);
                                extractedFileName = decoded;
                            } catch (e) {
                                console.log('íŒŒì¼ëª… ë””ì½”ë”© ì‹¤íŒ¨:', e.message);
                            }
                        }
                    }
                }

                // ì¶”ì¶œëœ íŒŒì¼ëª…ì´ ìˆê³ , ìœ íš¨í•œ ê²½ìš°ì—ë§Œ ì‚¬ìš©
                if (extractedFileName && extractedFileName.trim() && extractedFileName !== 'attachment') {
                    fileName = extractedFileName;
                    console.log('Content-Dispositionì—ì„œ íŒŒì¼ëª… ì‚¬ìš©:', fileName);
                }
            } else if (isFromGoDownload) {
                // console.log('goDownload ì›ë³¸ íŒŒì¼ëª… ìš°ì„  ì‚¬ìš©:', fileName);
            }

            // íŒŒì¼ëª… ì •ë¦¬ (í•œê¸€ ë³´ì¡´)
            const cleanFileName = sanitize(fileName, { replacement: '_' });
            const filePath = path.join(attachDir, cleanFileName);

            // console.log(`ìµœì¢… íŒŒì¼ëª…: ${cleanFileName}`);
            // console.log(`ì €ì¥ ê²½ë¡œ: ${filePath}`);

            const writer = fs.createWriteStream(filePath);

            response.data.pipe(writer);

            return new Promise((resolve, reject) => {
                writer.on('finish', resolve);
                writer.on('error', reject);
            });

        } catch (error) {
            throw new Error(`ë§í¬ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: ${error.message}`);
        }
    }

    /**
     * í¼ ë°©ì‹ ë‹¤ìš´ë¡œë“œ (POST)
     */
    async downloadViaForm(attachment, attachDir, fileName) {
        try {
            // ë¸Œë¼ìš°ì €ë¥¼ ì‚¬ìš©í•˜ì—¬ í¼ ì œì¶œ
            await this.page.evaluate((onclick) => {
                eval(onclick);
            }, attachment.onclick);

            // ë‹¤ìš´ë¡œë“œ ëŒ€ê¸°
            await this.page.waitForTimeout(3000);

            console.log(`í¼ ë°©ì‹ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ: ${fileName}`);

        } catch (error) {
            throw new Error(`í¼ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨: ${error.message}`);
        }
    }

    /**
     * ë§ˆí¬ë‹¤ìš´ ì»¨í…ì¸  ìƒì„±
     */
    generateMarkdownContent(announcement, detailContent) {
        const lines = [];

        lines.push(`**ì œëª©**: ${announcement.title}`);
        lines.push('');

        lines.push(`**ì›ë³¸ URL**: ${detailContent.url}`);
        lines.push('');

        if (detailContent.date) {
            lines.push(`**ì‘ì„±ì¼**: ${detailContent.date.format('YYYY-MM-DD')}`);
            lines.push('');
        }

        if (detailContent.content) {
            lines.push('**ë‚´ìš©**:');
            lines.push('');
            lines.push(detailContent.content);
        }

        if (detailContent.attachments && detailContent.attachments.length > 0) {
            lines.push('');
            lines.push('**ì²¨ë¶€íŒŒì¼**:');
            lines.push('');
            detailContent.attachments.forEach((att, i) => {

                let attachInfo = ""
                // ë‹¤ìš´ë¡œë“œ URL ì •ë³´ê°€ ìˆëŠ” ê²½ìš° ì¶”ê°€
                if (att.downloadInfo && att.downloadInfo.actualDownloadUrl) {
                    attachInfo = `${i + 1}. ${att.name}: ${att.downloadInfo.actualDownloadUrl}`
                } else if (att.url) {
                    // downloadInfoê°€ ì—†ì–´ë„ ì›ë³¸ URLì´ ìˆìœ¼ë©´ í‘œì‹œ
                    attachInfo = `${i + 1}. ${att.name}: ${att.url}`
                } else {
                    attachInfo = `${i + 1}. ${att.name}`;
                }
                lines.push(attachInfo);
                lines.push('');
            });
        }

        return lines.join('\n');
    }


    async buildDetailUrl(announcement) {
        console.log('URL êµ¬ì„± ì¤‘:', {
            link: announcement.link,
            onclick: announcement.onclick,
            dataAction: announcement.dataAction
        });

        // 1. data-action ì†ì„±ì´ ìˆëŠ” ê²½ìš° (ìš°ì„ ìˆœìœ„ ë†’ìŒ)
        if (announcement.dataAction) {
            const detailUrl = new URL(announcement.dataAction, this.baseUrl).toString();
            return detailUrl;
        }

        // 2. ì´ë¯¸ ì™„ì „í•œ URLì¸ ê²½ìš°
        const link = announcement.link;
        if (link && link.startsWith('http') && !link.endsWith('#')) {
            return link;
        }

        // 3. ìƒëŒ€ URLì¸ ê²½ìš°
        if (link && link.startsWith('/')) {
            return new URL(link, this.baseUrl).toString();
        }

        const downloadUrl = announcement.onclick
        // 4. onclick ì´ë²¤íŠ¸ì—ì„œ URL ì¶”ì¶œ ì‹œë„
        if (announcement.onclick) {

            //goDetialView(id, num, type, key)

            const regex = /goDetialView\('([^']+)',\s*'([^']+)',\s*'([^']*)',\s*'([^']*)'\)/;

            const matches = downloadUrl.match(regex);

            const id = matches[1];
            const num = matches[2];
            const type = matches[3];
            const key = matches[4];

            // ì§ì ‘ ìƒì„¸ í˜ì´ì§€ URL êµ¬ì„±
            const detailUrl = `https://www.haenam.go.kr/index.9is?contentUid=18e3368f7913117f01791bdc63505ada&notmgtNoView=${id}&nowPageNum=${num}&searchType2=${type}&keyword=${key}&recordCountPerPage=10`;
            console.log('êµ¬ì„±ëœ ìƒì„¸ í˜ì´ì§€ URL:', detailUrl);
            return detailUrl;

        }

        // JavaScript void(0) ë§í¬ì˜ ê²½ìš° ë¸Œë¼ìš°ì € í´ë¦­ ì‹œë„
        if (link === 'javascript:void(0);' && announcement.onclick) {
            console.log('javascript:void(0) ë§í¬ ê°ì§€, ë¸Œë¼ìš°ì € í´ë¦­ ë°©ì‹ ì‹œë„...');
            const clickUrl = await this.getUrlByBrowserClick(announcement);
            if (clickUrl) {
                return clickUrl;
            }
        }

        return null;
    }
    /**
     * ë¸Œë¼ìš°ì €ì—ì„œ ì‹¤ì œ í´ë¦­í•˜ì—¬ URL í™•ì¸
     */
    async getUrlByBrowserClick(announcement) {
        try {
            // í˜„ì¬ í˜ì´ì§€ì—ì„œ í•´ë‹¹ ì œëª©ì˜ ë§í¬ë¥¼ ì°¾ì•„ í´ë¦­
            const linkClicked = await this.page.evaluate((title) => {
                const links = document.querySelectorAll('table.bod_list tbody tr td:nth-child(3) a');
                for (let link of links) {
                    if (link.textContent.trim().includes(title.substring(0, 20))) {
                        // ìƒˆ íƒ­ì—ì„œ ì—´ë¦¬ë„ë¡ target ì„¤ì •
                        link.setAttribute('target', '_blank');
                        link.click();
                        return true;
                    }
                }
                return false;
            }, announcement.title);

            if (linkClicked) {
                // ìƒˆ í˜ì´ì§€ ëŒ€ê¸°
                const newPage = await this.context.waitForEvent('page', { timeout: 5000 });
                await newPage.waitForLoadState('networkidle');

                const url = newPage.url();
                await newPage.close();

                console.log('ë¸Œë¼ìš°ì € í´ë¦­ìœ¼ë¡œ í™•ì¸ëœ URL:', url);
                return url;
            }

        } catch (error) {
            console.log('ë¸Œë¼ìš°ì € í´ë¦­ ë°©ì‹ ì‹¤íŒ¨:', error.message);
        }

        return null;
    }

    /**
     * ë‚ ì§œ ì¶”ì¶œ
     */
    extractDate(dateText) {
        if (!dateText) return null;

        // í…ìŠ¤íŠ¸ ì •ë¦¬
        let cleanText = dateText.trim();

        // "ë“±ë¡ì¼\n2025-09-10" ê°™ì€ í˜•ì‹ì—ì„œ ë‚ ì§œë§Œ ì¶”ì¶œ
        const dateMatch = cleanText.match(/(\d{4}[-.\\/]\d{1,2}[-.\\/]\d{1,2})/);
        if (dateMatch) {
            cleanText = dateMatch[1];
        }

        // ë‹¤ì–‘í•œ ë‚ ì§œ í˜•ì‹ ì‹œë„

        // YY.MM.DD í˜•ì‹ ì²´í¬ (ì˜ˆ: 24.12.31)
        const yymmddMatch = cleanText.match(/^(\d{2})\-(\d{1,2})\-(\d{1,2})$/);
        if (yymmddMatch) {
            // 2ìë¦¬ ì—°ë„ë¥¼ 4ìë¦¬ë¡œ ë³€í™˜ (00-99 â†’ 2000-2099)
            const year = '20' + yymmddMatch[1];
            const month = yymmddMatch[2].padStart(2, '0');
            const day = yymmddMatch[3].padStart(2, '0');
            cleanText = `${year}-${month}-${day}`;
        }


        const formats = [
            'YYYY-MM-DD',
            'YYYY-MM-DD',
            'YYYY.MM.DD',
            'YYYY/MM/DD',
            'MM-DD-YYYY',
            'MM.DD.YYYY',
            'MM/DD/YYYY'
        ];

        for (const format of formats) {
            const date = moment(cleanText, format, true);
            if (date.isValid()) {
                return date;
            }
        }

        // ìì—°ì–´ í˜•ì‹ ì‹œë„ (ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ)
        const naturalDate = moment(cleanText);
        if (naturalDate.isValid() && cleanText.match(/\d{4}/)) {
            return naturalDate;
        }

        return null;
    }

    /**
     * ëŒ€ê¸°
     */
    async delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    /**
     * ì •ë¦¬ ì‘ì—…
     */
    async cleanup() {
        if (this.browser) {
            try {
                // ì»¨í…ìŠ¤íŠ¸ ë° ë¸Œë¼ìš°ì € ë‹«ê¸°
                if (this.context) {
                    await this.context.close();
                }

                await this.browser.close();
                console.log('\\në¸Œë¼ìš°ì € ì •ë¦¬ ì™„ë£Œ');

            } catch (error) {
                console.warn('ë¸Œë¼ìš°ì € ì •ë¦¬ ì¤‘ ì˜¤ë¥˜:', error.message);
            }
        }

        console.log(`\\n=== ìŠ¤í¬ë˜í•‘ ì™„ë£Œ ===`);
        console.log(`ì²˜ë¦¬ëœ ê³µê³  ìˆ˜: ${this.counter - 1}`);
        console.log(`ì¶œë ¥ ë””ë ‰í† ë¦¬: ${this.outputDir}`);
    }

    /**
     * ë¦¬ìŠ¤íŠ¸ URL êµ¬ì„±
     */
    buildListUrl(pageNum) {
        // ê¸°ë³¸ì ìœ¼ë¡œ page íŒŒë¼ë¯¸í„°ë¥¼ ì¶”ê°€
        const url = new URL(this.baseUrl);

        url.searchParams.set('curPage', pageNum);
        return url.toString();
    }


}

// CLI ì¸í„°í˜ì´ìŠ¤ (ì§ì ‘ ì‹¤í–‰ì‹œì—ë§Œ)
function setupCLI() {
    return yargs
        .option('year', {
            alias: 'y',
            type: 'number',
            description: 'ëŒ€ìƒ ì—°ë„',
            default: new Date().getFullYear()
        })
        .option('date', {
            alias: 'd',
            type: 'string',
            description: 'ëŒ€ìƒ ë‚ ì§œ (YYYY-MM-DD í˜•ì‹, year ëŒ€ì‹  ì‚¬ìš©)',
            default: null
        })
        .option('go-page', {
            alias: 'g',
            type: 'number',
            description: 'ì‹œì‘ í˜ì´ì§€ ë²ˆí˜¸',
            default: 1
        })
        .option('output', {
            alias: 'o',
            type: 'string',
            description: 'ì¶œë ¥ ë””ë ‰í† ë¦¬',
            default: 'scraped_data'
        })
        .option('site', {
            alias: 's',
            type: 'string',
            description: 'ì‚¬ì´íŠ¸ ì½”ë“œ',
            default: 'ulsan',
            required: true
        })
        .option('url', {
            alias: 'u',
            type: 'string',
            description: 'ê¸°ë³¸ URL',
            default: 'https://www.ulsan.go.kr/u/rep/transfer/notice/list.ulsan?mId=001004002000000000',
            required: true
        })
        .option('list-selector', {
            type: 'string',
            description: 'ë¦¬ìŠ¤íŠ¸ ì„ íƒì',
            default: 'table.tbl_bd_list > tbody > tr'
        })
        .option('title-selector', {
            type: 'string',
            description: 'ì œëª© ì„ íƒì',
            default: 'td:nth-child(2) a'
        })
        .option('date-selector', {
            type: 'string',
            description: 'ë‚ ì§œ ì„ íƒì',
            default: 'td:nth-child(6) '
        })
        .help()
        .argv;
}

// ë©”ì¸ ì‹¤í–‰
async function main() {
    const argv = setupCLI();

    const scraper = new AnnouncementScraper({
        targetYear: argv.year,
        targetDate: argv.date,
        goPage: argv.goPage,
        outputDir: argv.output,
        siteCode: argv.site,
        baseUrl: argv.url,
        listSelector: argv.listSelector,
        titleSelector: argv.titleSelector,
        dateSelector: argv.dateSelector
    });

    await scraper.scrape();
}

// ìŠ¤í¬ë¦½íŠ¸ê°€ ì§ì ‘ ì‹¤í–‰ë  ë•Œë§Œ main í•¨ìˆ˜ í˜¸ì¶œ
if (require.main === module) {
    main().catch(console.error);
}

module.exports = AnnouncementScraper;
